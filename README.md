# Лабораторная работа 7. Преобразование и анализ кода с использованием Clang и LLVM

## Цель работы
Познакомиться с инструментами Clang и LLVM,
научиться собирать AST и IR-промежуточное представление кода на
C/C++, а также извлекать базовую информацию о программе (например,
список функций).


## Задачи

1. Установить Clang и LLVM;
2. Скомпилировать простой C-файл с использованием clang и
получить его: абстрактное синтаксическое дерево (AST), промежуточное
представление LLVM IR;
3. Использовать opt для применения базовой комплексной
оптимизации (например, О2);
4. Построить граф потока управления (CFG) для оптимизированной
программы;
5. Проанализировать результат, сделать выводы и ответить на
контрольные вопросы

## Ход работы
### 1. Установка и подготовка среды

   Работа выполнялась в среде Ubuntu 22.04. Установлены следующие
инструменты:
* clang — компилятор языка C/C++;
* llvm — инструменты анализа и оптимизации кода;
* opt — инструмент для работы с LLVM IR и применения
оптимизаций;
* Graphviz — инструмент для визуализации кода.

Команда установки: 
```
$ sudo apt install clang llvm
```
[]

### 2. Исходный код
   Программа на языке C:
   ```с
    #include <stdio.h>
    int square(int x) {
    return x * x;
    }
    int main() {
        int a = 5;
        int b = square(a);
        printf("%d\n", b);
        return 0;
    }

   ```
   Сохранена в файл main.c.
   []

### 3. Получение AST
Команда: 
```
clang -Xclang -ast-dump -fsyntax-only main.c
```
[]

Функция square принята, содержит параметр x и возвращает x * x

### 4. Генерация LLVM IR

Команда: 
```
clang -S -emit-llvm main.c -o main.ll
```
[]

### 5. Оптимизация IR

Команда: 
```
clang -O0 -S -emit-llvm main.c -o main_O0.ll
```

Стоит отметить, что в файле с IR до оптимизации:


Все переменные (a, b, x.addr) размещены в памяти через alloca;


Множество операций load и store;


square вызывается как отдельная функция
[]

Команда: 
```
clang -O2 -S -emit-llvm main.c -o main_O2.ll
```

Команда -O2 – комплексная оптимизация среднего уровня. Она
применяет более 30 различных оптимизаций:
* -inline – встраивание небольших функций (встраивает square в
main, если она вызывается один раз);
* -constprop – подставит значение square(5) → 25, если функция
встроена и всё известно на этапе компиляции;
* -mem2reg – перевод переменных из памяти в регистры (SSA);
* -instcombine – объединение и упрощение инструкций
(упростит арифметику, например x * x может быть преобразовано в shl при
x = 2^n);
* -simplifycfg – оптимизирует структуру блоков (Упростит граф
управления, если после inlining останутся лишние блоки);
* -reassociate, -gvn, -sroa, -dce и другие.

В файле с IR после оптимизации:
Вся функция square исчезла – она была встроена (-inline) и затем
вычислена (оптимизация -constprop);


Никаких переменных, alloca, store, load – всё удалено (оптимизации
-mem2reg, -dce);


Остался только вызов printf(25).

[]

Команда: 
```
diff main_O0.ll main_O2.ll
```
Сравнение двух файлов:
[]
Стоит отметить, что после оптимизации произошли следующие
изменения:
* Переменные типа alloca были удалены;
* Код переведён в SSA-форму;
* Оптимизация улучшила читаемость и упростила поток
управления

### 6. Граф потока управления программы

Команда для генерации оптимизированного LLVM IR: 
```
clang -O2 -S-emit-llvm main.c -o main.ll
```


Команда для генерации .dot-файлов CFG для функций:
```
opt -dot-cfg-disable-output main.ll
```
[]

Эта команда создаст DOT-файлы: .main.dot – для функции main;
.square.dot – для square, если она не была удалена оптимизацией.


Команда для установки библиотеки Graphviz: 
```
sudo apt install graphviz
```
Команды для преобразования файлов с расширением .dot в .png с
помощью Graphviz:
```
dot -Tpng .main.dot -o cfg_main.png
dot -Tpng .square.dot -o cfg_square.png
```
Команды для просмотра файлов с CGF:
```
xdg-open cfg_main.png
```

[]

```
xdg-open cfg_square.png
```
Стоит отметить, что в LLVM каждый граф потока управления (CFG)
строится на уровне функции, поскольку структура управления всегда
локальна для тела функции. Для получения полного представления о
программе, нужно построить CFG для всех функций и анализировать их
совокупность. Автоматическое объединение всех CFG в один граф не
предусмотрено в LLVM по умолчанию.

## Выводы
* С помощью Clang можно получить полную структуру AST и
IR, а также CGF;
* LLVM предоставляет гибкие инструменты анализа и
оптимизации;
* Промежуточное представление кода удобно для написания
компиляторных трансформаций


## Список контрольных вопросов
### 1. Что такое Clang, и какова его роль в процессе компиляции программ?
2
### 2. Что представляет собой LLVM и как он используется в современных компиляторах?
1
### 3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?
### 4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?
### 5. Что делает инструкция alloc в LLVM IR, и зачем она используется в функциях?
### 6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?
### 7. Что такое SSA-форма и почему она важна при оптимизации программ?
### 8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?
### 9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?
### 10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?
### 11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?
### 12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?

