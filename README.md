# Лабораторная работа 7. Преобразование и анализ кода с использованием Clang и LLVM

## Цель работы
Познакомиться с инструментами Clang и LLVM,
научиться собирать AST и IR-промежуточное представление кода на
C/C++, а также извлекать базовую информацию о программе (например,
список функций).


## Задачи

1. Установить Clang и LLVM;
2. Скомпилировать простой C-файл с использованием clang и
получить его: абстрактное синтаксическое дерево (AST), промежуточное
представление LLVM IR;
3. Использовать opt для применения базовой комплексной
оптимизации (например, О2);
4. Построить граф потока управления (CFG) для оптимизированной
программы;
5. Проанализировать результат, сделать выводы и ответить на
контрольные вопросы

## Ход работы
### 1. Установка и подготовка среды

   Работа выполнялась в среде Ubuntu 22.04. Установлены следующие
инструменты:
* clang — компилятор языка C/C++;
* llvm — инструменты анализа и оптимизации кода;
* opt — инструмент для работы с LLVM IR и применения
оптимизаций;
* Graphviz — инструмент для визуализации кода.

Команда установки: 
```
$ sudo apt install clang llvm
```
![image](https://github.com/user-attachments/assets/c14b8f60-9b8b-4dde-9273-099f148e9d6e)


### 2. Исходный код
   Программа на языке C:
   ```с
    #include <stdio.h>
    int square(int x) {
    return x * x;
    }
    int main() {
        int a = 5;
        int b = square(a);
        printf("%d\n", b);
        return 0;
    }

   ```
   Сохранена в файл main.c.
   ![image](https://github.com/user-attachments/assets/05c8c00c-a650-4bb1-90bc-929bc87e7368)


### 3. Получение AST
Команда: 
```
clang -Xclang -ast-dump -fsyntax-only main.c
```
![image](https://github.com/user-attachments/assets/81b12f5c-d6c5-4dce-a06c-cc8abfc5d2a0)


Функция square принята, содержит параметр x и возвращает x * x

### 4. Генерация LLVM IR

Команда: 
```
clang -S -emit-llvm main.c -o main.ll
```
![image](https://github.com/user-attachments/assets/4dc2d9f2-7216-4aa0-86e7-8ce934a12346)


### 5. Оптимизация IR

Команда: 
```
clang -O0 -S -emit-llvm main.c -o main_O0.ll
```

Стоит отметить, что в файле с IR до оптимизации:


Все переменные (a, b, x.addr) размещены в памяти через alloca;


Множество операций load и store;


square вызывается как отдельная функция
![image](https://github.com/user-attachments/assets/73444dec-f9d4-43c2-b74a-f735b2e01970)

Команда: 
```
clang -O2 -S -emit-llvm main.c -o main_O2.ll
```

Команда -O2 – комплексная оптимизация среднего уровня. Она
применяет более 30 различных оптимизаций:
* -inline – встраивание небольших функций (встраивает square в
main, если она вызывается один раз);
* -constprop – подставит значение square(5) → 25, если функция
встроена и всё известно на этапе компиляции;
* -mem2reg – перевод переменных из памяти в регистры (SSA);
* -instcombine – объединение и упрощение инструкций
(упростит арифметику, например x * x может быть преобразовано в shl при
x = 2^n);
* -simplifycfg – оптимизирует структуру блоков (Упростит граф
управления, если после inlining останутся лишние блоки);
* -reassociate, -gvn, -sroa, -dce и другие.

В файле с IR после оптимизации:
Вся функция square исчезла – она была встроена (-inline) и затем
вычислена (оптимизация -constprop);


Никаких переменных, alloca, store, load – всё удалено (оптимизации
-mem2reg, -dce);


Остался только вызов printf(25).

![image](https://github.com/user-attachments/assets/0c85ecbc-a0f7-4a6e-a433-5dea695f32db)


Команда: 
```
diff main_O0.ll main_O2.ll
```
Сравнение двух файлов:
![image](https://github.com/user-attachments/assets/ab70a892-8a71-49d8-9ecc-a441c58a7a7a)

Стоит отметить, что после оптимизации произошли следующие
изменения:
* Переменные типа alloca были удалены;
* Код переведён в SSA-форму;
* Оптимизация улучшила читаемость и упростила поток
управления

### 6. Граф потока управления программы

Команда для генерации оптимизированного LLVM IR: 
```
clang -O2 -S-emit-llvm main.c -o main.ll
```


Команда для генерации .dot-файлов CFG для функций:
```
opt -dot-cfg-disable-output main.ll
```
![image](https://github.com/user-attachments/assets/7791bdf9-632e-4c8b-8967-42fb393ed0da)


Эта команда создаст DOT-файлы: .main.dot – для функции main;
.square.dot – для square, если она не была удалена оптимизацией.


Команда для установки библиотеки Graphviz: 
```
sudo apt install graphviz
```
Команды для преобразования файлов с расширением .dot в .png с
помощью Graphviz:
```
dot -Tpng .main.dot -o cfg_main.png
dot -Tpng .square.dot -o cfg_square.png
```
Команды для просмотра файлов с CGF:
```
xdg-open cfg_main.png
```

![cfg_main](https://github.com/user-attachments/assets/7df4e9bb-d1f8-4cec-bfe2-660774ab0093)

```
xdg-open cfg_square.png
```
![cfg_square](https://github.com/user-attachments/assets/1ee314db-335d-4e57-98f8-ee92ebe918c5)

Стоит отметить, что в LLVM каждый граф потока управления (CFG)
строится на уровне функции, поскольку структура управления всегда
локальна для тела функции. Для получения полного представления о
программе, нужно построить CFG для всех функций и анализировать их
совокупность. Автоматическое объединение всех CFG в один граф не
предусмотрено в LLVM по умолчанию.

## Выводы
* С помощью Clang можно получить полную структуру AST и
IR, а также CGF;
* LLVM предоставляет гибкие инструменты анализа и
оптимизации;
* Промежуточное представление кода удобно для написания
компиляторных трансформаций


## Список контрольных вопросов
### 1. Что такое Clang, и какова его роль в процессе компиляции программ?
Clang – это компилятор (фронтенд) для языков программирования C, C++, Objective-C, Objective-C++ и OpenCL, который используется вместе с фреймворком LLVM. Его основная роль – преобразовать исходный код программы в машинный код (или промежуточный код, в зависимости от настроек компиляции).
### 2. Что представляет собой LLVM и как он используется в современных компиляторах?
LLVM – это проект программной инфраструктуры, используемый для создания компиляторов и других утилит, связанных с компиляцией. Он предоставляет набор инструментов для компиляции, оптимизации и интерпретации кода. LLVM позволяет разрабатывать компиляторы для различных языков программирования, а также предоставляет платформенную независимость, позволяя создавать код, работающий на разных архитектурах.
### 3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?
AST — это структурированное представление исходного кода, отражающее синтаксис и структуру программы. Его строит Clang после разбора исходного кода на C/C++. LLVM IR — это низкоуровневое, платформонезависимое представление программы, ближе к машинному коду. Его генерирует Clang после анализа AST.
### 4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?
Промежуточное представление нужно в процессе компиляции для того, чтобы упростить и стандартизировать анализ, оптимизацию и генерацию машинного кода. Оно позволяет отделить этап разбора исходного языка от этапа генерации исполняемого файла, облегчая поддержку разных языков программирования и архитектур. Благодаря IR компилятор может применять универсальные оптимизации и работать с программой на более низком уровне, но ещё до создания платформозависимого кода.
### 5. Что делает инструкция alloc в LLVM IR, и зачем она используется в функциях?
Инструкция alloca выделяет память на стеке внутри функции. Она используется для создания локальных переменных, аналогично тому, как в C создаются переменные внутри функции. Позволяет временно хранить данные, пока выполняется функция.
### 6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?
Оптимизация улучшает производительность и уменьшает размер кода. Цель — сделать программу быстрее, использовать меньше памяти, упростить структуру, устранить ненужные вычисления и повысить эффективность выполнения.
### 7. Что такое SSA-форма и почему она важна при оптимизации программ?
SSA — форма представления программы, в которой каждая переменная присваивается только один раз. Это упрощает анализ зависимостей между переменными и позволяет компилятору безопасно и эффективно выполнять оптимизации, такие как устранение мёртвого кода или подстановка значений.
### 8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?
CFG — это граф, где узлы представляют блоки кода, а рёбра — возможные переходы исполнения. Он помогает понять, как программа выполняется, где могут возникать ветвления, циклы и условия, и служит основой для анализа и оптимизации кода.
### 9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?
Арифметические операции в LLVM IR записываются как команды низкого уровня, например add, mul, sub. Они работают с переменными и константами напрямую и похожи на ассемблерные инструкции, но платформонезависимы.
### 10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?
Потому что каждая функция имеет независимую структуру управления и переменные. Это позволяет анализировать и оптимизировать её изолированно, встраивать (inline) в другие функции или удалять, если она не используется.
### 11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?
Компилятор может встроить её (inline) в вызывающую функцию. После этого она может быть удалена, если нигде больше не используется. Это уменьшает количество вызовов и ускоряет выполнение.
### 12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?
IR и CFG упрощают структуру программы, устраняют синтаксическую сложность и делают поведение кода более предсказуемым. Это позволяет применять универсальные и мощные оптимизации, которые невозможно или сложно выполнить на уровне исходного текста.

